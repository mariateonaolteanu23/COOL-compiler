sequence(e) ::= "<e; separator=\"\n\">"
sequenceSpaced(e) ::= "<e; separator=\"\n\n\">"

program(constString, constInt, constBool,
        className, classObjTab, classProtObj, classDispTab,
        classInitSignature, functionSignature, classInitBody, functionInitBody) ::= <<
.data

.align 2
.globl class_nameTab
.globl Int_protObj
.globl String_protObj
.globl bool_const0
.globl bool_const1
.globl Main_protObj
.globl _int_tag
.globl _string_tag
.globl _bool_tag

_int_tag:
    .word 2
_string_tag:
    .word 3
_bool_tag:
    .word 4

#lista de strConstEntry.
<constString>

#lista de intConstEntry.
<constInt>

#list de boolConstEntry.
<constBool>

#lista de classNameEntry. de fapt pointer catre str_const care retine numele clasei.
class_nameTab:
<className>

# prototipul clasei. functia de initializare a unei clase. lista de classObjTabEntry.
class_objTab:
<classObjTab>

#prototipul unei clase. lista de classProtObjEntry.
<classProtObj>

#dispatch table clasa. ce functii poate apela fiecare clasa. lista de classDispTabEntry.
<classDispTab>

.globl heap_start
heap_start:
    .word 0

.text

#lista de classInitSignatureEntry.
<classInitSignature>

#lista de functionSignatureEntry.
<functionSignature>

#lista de classInitBodyEntry.
<classInitBody>

#lista de functionInitBodyEntry.
<functionInitBody>
>>



constStringEntry(index, size, indexLengthConstInt, value) ::= <<
str_const<index>:
    .word 3
    .word <size>
    .word String_dispTab
    .word int_const<indexLengthConstInt>
    .asciiz "<value>"
    .align 2
>>

constIntEntry(index, value) ::= <<
int_const<index>:
    .word 2
    .word 4
    .word Int_dispTab
    .word <value>
>>

constBoolEntry(index, value) ::= <<
bool_const<index>:
    .word 4
    .word 4
    .word Bool_dispTab
    .word <value>
>>



classNameEntry(classNameIndex) ::= <<
    .word str_const<classNameIndex>
>>

classObjTabEntry(className) ::= <<
    .word <className>_protObj
    .word <className>_init
>>

classProtObjEntry(className, classTag, size, features) ::= <<
<className>_protObj:
    .word <classTag>
    .word <size>
    .word <className>_dispTab
    <features>
>>

featureEntry(value) ::= <<
.word <value>
>>





classDispTabEntry(className, functionPointer) ::= <<
<className>_dispTab: #lista de functionPointerEntry.
    <functionPointer>
>>

functionPointerEntry(className, funcName) ::= <<
.word <className>.<funcName>
>>




classInitSignatureEntry(className) ::= <<
.globl <className>_init
>>

functionSignatureEntry(className, funcName) ::= <<
.globl <className>.<funcName>
>>





functionPreamble(funcName, body) ::= <<
<funcName>:
    addiu $sp $sp -12
    sw $fp 12($sp)
    sw $s0 8($sp)
    sw $ra 4($sp)
    addiu $fp $sp 4
    move $s0 $a0
    <body>
    move $a0 $s0
    lw $fp 12($sp)
    lw $s0 8($sp)
    lw $ra 4($sp)
    addiu $sp $sp 12
    jr $ra
>>



literal(value) ::= <<
la $a0 <value>
>>

dispatch(funcParams, label, errFile, errLine, offset, caller, objectResolution, resetStackPointer) ::= <<
<funcParams>
<objectResolution> #f(x).g(y) = explicit dispatch cu obj f(x), id g si arg y. tb rezolvat intai f(x).
<caller> #pe cine dereferentiez. pentru implicit e self (a0 = s0). pentru explicit e adresa class_protObj.
bnez $a0 dispatch<label>
la   $a0 str_const<errFile>
li   $t1 <errLine>
jal  _dispatch_abort
dispatch<label>:
    lw  $t1 8($a0) # dispatch table
    lw  $t1 <offset>($t1) # method offset
    jalr $t1
#addiu $sp $sp <resetStackPointer>
>>

param(e) ::= <<
<e>
    sw $a0 0($sp)
    addiu $sp $sp -4
>>

self() ::= <<
move $a0 $s0
>>

attribute(offset) ::= <<
lw $a0 <offset>($s0)
>>