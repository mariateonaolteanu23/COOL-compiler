sequence(e) ::= "<e; separator=\"\n\">"
sequenceSpaced(e) ::= "<e; separator=\"\n\n\">"

program(constString, constInt, constBool,
        className, classObjTab, classProtObj, classDispTab,
        classInitSignature, functionSignature, classInitBody, functionInitBody) ::= <<
.data

.align 2
.globl class_nameTab
.globl Int_protObj
.globl String_protObj
.globl bool_const0
.globl bool_const1
.globl Main_protObj
.globl _int_tag
.globl _string_tag
.globl _bool_tag

_int_tag:
    .word 2
_string_tag:
    .word 3
_bool_tag:
    .word 4

#lista de strConstEntry.
<constString>

#lista de intConstEntry.
<constInt>

#list de boolConstEntry.
<constBool>

#lista de classNameEntry. de fapt pointer catre str_const care retine numele clasei.
class_nameTab:
<className>

# prototipul clasei. functia de initializare a unei clase. lista de classObjTabEntry.
class_objTab:
<classObjTab>

#prototipul unei clase. lista de classProtObjEntry.
<classProtObj>

#dispatch table clasa. ce functii poate apela fiecare clasa. lista de classDispTabEntry.
<classDispTab>

.globl heap_start
heap_start:
    .word 0

.text

#lista de classInitSignatureEntry.
<classInitSignature>

#lista de functionSignatureEntry.
<functionSignature>

#lista de classInitBodyEntry.
<classInitBody>

#lista de functionInitBodyEntry.
<functionInitBody>
>>



constStringEntry(index, size, indexLengthConstInt, value) ::= <<
str_const<index>:
    .word 3
    .word <size>
    .word String_dispTab
    .word int_const<indexLengthConstInt>
    .asciiz "<value>"
    .align 2
>>

constIntEntry(index, value) ::= <<
int_const<index>:
    .word 2
    .word 4
    .word Int_dispTab
    .word <value>
>>

constBoolEntry(index, value) ::= <<
bool_const<index>:
    .word 4
    .word 4
    .word Bool_dispTab
    .word <value>
>>



classNameEntry(classNameIndex) ::= <<
    .word str_const<classNameIndex>
>>

classObjTabEntry(className) ::= <<
    .word <className>_protObj
    .word <className>_init
>>

classProtObjEntry(className, classTag, size, features) ::= <<
<className>_protObj:
    .word <classTag>
    .word <size>
    .word <className>_dispTab
    <features>
>>

featureEntry(value) ::= <<
.word <value>
>>





classDispTabEntry(className, functionPointer) ::= <<
<className>_dispTab: #lista de functionPointerEntry.
    <functionPointer>
>>

functionPointerEntry(className, funcName) ::= <<
.word <className>.<funcName>
>>




classInitSignatureEntry(className) ::= <<
.globl <className>_init
>>

functionSignatureEntry(className, funcName) ::= <<
.globl <className>.<funcName>
>>





functionPreamble(funcName, body, optionalResetStack) ::= <<
<funcName>:
    addiu $sp $sp -12
    sw $fp 12($sp)
    sw $s0 8($sp)
    sw $ra 4($sp)
    addiu $fp $sp 4
    move $s0 $a0
    <body>
    lw $fp 12($sp)
    lw $s0 8($sp)
    lw $ra 4($sp)
    addiu $sp $sp 12
    <optionalResetStack>
    jr $ra
>>

literal(value) ::= <<
la $a0 <value>
>>

dispatch(funcParams, label, errFile, errLine, offset, caller, objectResolution) ::= <<
<funcParams>
<objectResolution> #f(x).g(y) = explicit dispatch cu obj f(x), id g si arg y. tb rezolvat intai f(x).
<caller> #pe cine dereferentiez. pentru implicit e self (a0 = s0). pentru explicit e adresa class_protObj.
bnez $a0 dispatch<label>
la   $a0 str_const<errFile>
li   $t1 <errLine>
jal  _dispatch_abort
dispatch<label>:
    lw  $t1 8($a0) # dispatch table
    lw  $t1 <offset>($t1) # method offset
    jalr $t1
>>

param(e) ::= <<
<e>
sw $a0 0($sp)
addiu $sp $sp -4
>>

letParam(e, offset) ::= <<
<e>
sw $a0 <offset>($fp)
>>

self() ::= <<
move $a0 $s0
>>


optionalResetStack(amount) ::= <<
addiu $sp $sp <amount>
>>

let(n, params, body, optionalResetStack) ::= <<
<optionalResetStack(n)>
<params>
<body>
<optionalResetStack>
>>

store(offset, reg) ::= <<
sw $a0 <offset>(<reg>)
>>

load(offset, reg) ::= <<
lw $a0 <offset>(<reg>) #TODO mod s0
>>

new(type) ::= <<
la $a0 <type>_protObj
jal Object.copy
jal <type>_init
>>

new_self() ::= <<
la     $t1 class_objTab
lw      $t2 0($s0)          # class tag
sll     $t2 $t2 3           # *8
addu    $t1 $t1 $t2         # class_objTab + 8 * tag
sw      $t1 0($sp)
addiu   $sp $sp -4
lw      $a0 0($t1)          # _protObj
jal     Object.copy
lw      $t1 4($sp)
addiu   $sp $sp 4
lw      $t1 4($t1)          # _init
jalr    $t1
>>
